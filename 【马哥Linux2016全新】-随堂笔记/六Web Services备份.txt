nginx
	
	web服务器：http协议
	
	http协议: html, 文本, MIME
		major/minor: text/plain, text/html, image/jpeg
		
		web资源：URL (scheme://server:port/path/to/source)
		
		方法：GET, HEAD, POST, (WEBDAV) PUT, DELETE, TRACE, OPTIONS
		
		http事务：request <----> response
			request:
				<method> <URL> <version>
				<HEADERS>
				
				<body>
				
			response:
				<version> <status> <reason phrase>
				<HEADERS>
				
				<body>
				
			status: 
				1xx: 信息类
				2xx: 成功类，200
				3xx: 重定向，301, 302, 304
				4xx: 客户端类错误，403, 401, 404
				5xx: 服务端类错误，502
				
		页面：多个资源
			请求资源：是入口
				HREF:80, 40
			
		认证：
			基于IP
			基于用户
				basic
				digest
			
		httpd: MPM
			prefork, worker, event
			
		I/O类型：
			同步和异步：synchronous, asyncrhonous
				关注的是消息通知机制
				
				同步：调用发出不会立即返回，但一旦返回就可以返回最终结果；
				异步：调用发出之后，被调用方立即返回消息，但返回的非最终结果；被调用者通过状态、通知机制来通知调者，或通过回调函数来处理结果；
			
			阻塞和非阻塞：block, nonblock
				关注的是调用等等调用结果（消息、返回值）时的状态
				
				阻塞：调用结果返回之前，调用者（调用线程）会被挂起；调用者只有在得到结果之后才会返回；
				非阻塞：调用结果返回之前，调用不会阻塞当前线程；
				
		5种I/O模型：
			blocking IO
			nonblocking IO
			IO multiplexing
			signal driven IO
			asyncrhonous IO
			
		一个read操作：
			(1) 等等数据准备好；
			(2) 从内核向进程复制数据；
			
			select(),     poll()
			
			水平触发，边缘触发 

	Nginx：
	
		http://nginx.org/， C10k; 
		
		Igor Sysoev, Rambler Media; 
			engine X: nginx
		
			tengine, OpenResty
			
		Nginx的特性：
			模块化设计、较好扩展性；
			高可靠性
				master/worker
			支持热部署
				不停机更新配置文件、更换日志、更新服务器程序版本；
			低内存消耗
				10000个keep-alive连接模式下的非活动连接仅消耗2.5M内存；
			event-driven, aio, mmap；
			
		基本功能：
			静态资源的web服务器；
			http协议的反向代理服务器；
			pop3, smpt, imap4等邮件协议的反向代理；
			能缓存打开的文件（元数据）、支持FastCGI（php-fpm）, uWSGI（Python Web Framwork）等协议
			模块化（非DSO机制），过滤器zip，SSI，SSL；
			
		web服务相关的功能：
			虚拟主机（server）、keepalive、访问日志（支持基于日志缓冲提高其性能）、url rewirte、路径别名、基于IP及用户的访问控制、支持速率限制及并发数限制；
			……
			
		Nginx的基本架构：
			master/worker
				一个master进程，可生成一个或多个worker进程；
				事件驱动：epoll(Linux), kqueue（FreeBSD）, /dev/poll(Solaris)
					消息通知：select, poll, rt signals
				支持sendfile,  sendfile64
				支持AIO，mmap
			
				master: 加载配置文件、管理worker进程、平滑升级，...
				worker：http服务，http代理，fastcgi代理，...
				
		模块类型：
			核心模块：core module
			Standard HTTP modules
			Optional HTTP modules
			Mail modules
			3rd party modules
			
		用来做什么 ？
			静态资源的web服务器；
			http服务器反向代理；
			
	nginx安装配置：
	
		#
		# ./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf --user=nginx --group=nginx  --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx/nginx.pid --lock-path=/var/lock/nginx.lock --with-http_ssl_module --with-http_stub_status_module --with-http_gzip_static_module --with-debug
		# make && make install
		
		配置文件的组成部分：
			主配置文件：nginx.conf
				include conf.d/*.conf
				/etc/nginx/conf.d/*.conf
			fastcgi的配置文件：fastcgi_params
							   uwsgi_params
							   
		配置指令(必须以分号结尾)：
			Directive  value1 [value2...];
			
			支持使用变量：
				内置变量：由模块引入；
				自定义变量：
					set  variable  value; 
				
				引用变量：$variable 
				
		配置文件组织结构
			main block
			event {
				...
			}
			http {
				...
			}
			
			http配置段：
				http {
					...
					server {
						...
						server_name 
						root 
						alias
						location /uri/ {
							
						}
						...
					}
					server {
						...
					}
				}
			
			main配置段：
				类别：
					正常运行必备的配置；
					优化性能相关的配置；
					用于调试、定位问题的配置；
					
				正常运行必备的配置：
					1、user USERNAME  [GROUPNAME];
						指定用于运行worker进程的用户和组；
						
						user  nginx  nginx;
						
					2、pid  /PATH/TO/PID_FILE;
						指定nginx进程的pid文件路径；
						
						pid  /var/run/nginx.pid;
						
					3、worker_rlimit_nofile #;
						指定一个worker进程所能够打开的最大文件描述符数量；
						
					4、worker_rlimit_sigpending #;
						指定每个用户能够发往worker进程的信号的数量；
						
				性能优化相关的配置：
					1、worker_processes #;
						worker进程的个数；通常应该为物理CPU核心数量减1；
						可以为"auto"，实现自动设定；
						
					2、worker_cpu_affinity  CPUMASK CPUMASK ...;
						CPUMASK:
							0001
							0010
							0100
							1000 
							
						worker_cpu_affinity 00000001 00000010 00000100;
						
					3、worker_priority  nice;
						[-20, 19]
						
				调试、定位问题的配置：
					1、daemon  off|on;
						是否以守护进程方式启动nignx；
						
					2、master_process  on|off;
						是否以master/worker模型运行nginx；
						
					3、error_log  /PATH/TO/ERROR_LOG level;
						错误日志文件及其级别；出于调试的需要，可以设定为debug；但debug仅在编译时使用了“--with-debug”选项时才有效；
						
回顾：IO模型、Nginx
	
	IO模型：
		阻塞
		非阻塞
		IO复用（select, poll）
		信号驱动的IO（epoll, kqueue, /dev/poll）
		AIO 
		
		nginx特性：epoll, aio, mmap 
			master/worker
			
		nginx.conf
			main配置段
			event {
				...
			}
			http {
				...
				server {
					server_name
					root 
					location /uri/ {
						...
					}
				}
				server {
					...
				}
			}
			
Nginx(2)

	nginx.conf的配置：
		main配置段
		event {
			...
		}
		
			1、worker_connections #;
				每个worker进程所能够响应的最大并发请求数量；
				
				worker_proceses * worker_connections
				
			2、use  [epoll|rgsig|select|poll];
				定义使用的事件模型；建议让nginx自动选择；
					
			3、accept_mutex [on|off];
				各worker接收用户的请求的负载均衡锁；启用时，表示用于让多个worker轮流地、序列化地响应新请求；
				
			4、lock_file  /PATH/TO/LOCK_FILE; 
			
		http {
			...
		}
		
			套接字或主机相关的指令
				1、server {}
					定义一个虚拟主机；
					
					server {
						listen PORT;
						server_name NAME;
						root /PATH/TO/DOCUMENTROOT;
					}
					...
					
					注意：
						(1) 基于port；
							listen指令监听在不同的端口；
						(2) 基于hostname
							server_name指令指向不同的主机名；
				2、listen
					listen address[:port] [default_server] [ssl] [http2 | spdy] 
					listen port [default_server] [ssl] [http2 | spdy]
					
						default_server：设置默认虚拟主机；用于基于IP地址，或使用了任意不能对应于任何一个server的name时所返回站点；
						ssl：用于限制只能通过ssl连接提供服务；
						spdy：SPDY protocol（speedy），在编译了spdy模块的情况下，用于支持SPDY协议；
						http2：http version 2；
						
				3、server_name NAME [...];
					后可跟一个或多个主机名；名称还可以使用通配符和正则表达式(~)；
					
						(1) 首先做精确匹配；例如：www.magedu.com
						(2) 左侧通配符；例如：*.magedu.com
						(3) 右侧通配符，例如：www.magedu.*
						(4) 正则表达式，例如：~^.*\.magedu\.com$
						(5) default_server 
						
				4、tcp_nodelay on|off;
					对keepalive模式下的连接是否使用TCP_NODELAY选项；
					
				5、tcp_nopush on|off;
					是否启用TCP_NOPUSH(FREEBSE）或TCP_CORK(Linux)选项；仅在sendfile为on时有用；
					
				6、sendfile on|off;
					是否启用sendfile功能；
			
			路径相关的指令：
				7、root
					设置web资源的路径映射；用于指明请求的URL所对应的文档的目录路径；
					
						server {
							...
							root  /data/www/vhost1;
						}
						http://www.magedu.com/images/logo.jpg --> /data/www/vhosts/images/logo.jpg
						
						server {
							...
							server_name  www.magedu.com;
							location /images/ {
								root  /data/imgs/;
								...
							}
						}
						
						http://www.magedu.com/images/logo.jpg --> /data/imgs/images/logo.jpg
						
				8、	location [ = | ~ | ~* | ^~ ] uri { ... }
				        location @name { ... }
				        
				        功能：允许根据用户请求的URI来匹配定义的各location，匹配到时，此请求将被相应的location块中的配置所处理；简言之，即用于为需要用到专用配置的uri提供特定配置；
				        
						server {
							...
							server_name www.magedu.com;
							root /data/www;

							location  /admin/  {
								...
							}
						}
						
						=：URI的精确匹配；
						~：做正则表达式匹配，区分字符大小写；
						~*：做正则表达式匹配，不区分字符大小写；
						^~：URI的左半部分匹配，不区分字符大小写；
						
						匹配优先级：精确匹配=、^~、~或~*、不带符号的URL；
						
				9、alias
					只能用于location配置段，定义路径别名；
					
					location  /images/ {
						root /data/imgs/;
					}
					
					location  /images/  {
						alias /data/imgs/;
					}
					
					注意：
						root指令：给定的路径对应于location的“/”这个URL；
							/images/test.jpg -->  /data/imgs/images/test.jpg 
						alias指令：给定的路径对应于location的“/uri/"这个URL；
							/images/test.jpg -->  /data/imgs/test.jpg
				10、index 
					index file ...;
					
					默认主页面；
					
				11、error_page code ... [=[response]] uri;
					根据http的状态码重定向错误页面；
						error_page  404  /404.html
						error_page  404  =200  /404.html  （以指定的响应状态码进行响应）
						
				12、try_files file ... uri;
				        try_files file ... =code;
				        
				        尝试查找第1至第N-1个文件，第一个即为返回给请求者的资源；若1至N-1文件都不存在，则跳转至最一个uri（必须不能匹配至当前location，而应该匹配至其它location，否则会导致死循环）；
				        
			客户端请求相关的配置：
				
				13、keepalive_timeout timeout [header_timeout];
					设定keepalive连接的超时时长；0表示禁止长连接；默认为75s；
					
				14、keepalive_requests number;
					在keepalived连接上所允许请求的最大资源数量；默认为100；
				
				15、keepalive_disable none | browser ...;
					指明禁止为何种浏览器使用keepalive功能；
					
				16、send_timeout #;
					发送响应报文的超时时长，默认为60s; 
					
				17、client_body_buffer_size size;
					接收客户请求报文body的缓冲区大小；默认为16k；超出此指定大小时，其将被移存于磁盘上；

				18、client_body_temp_path path [level1 [level2 [level3]]];
					设定用于存储客户端请求body的临时存储路径及子目录结构和数量；
					
					client_body_temp_path  /var/tmp/client_body  2 2;
					
			对客户端请求的进行限制
				19、limit_excpet  METHOD {...}
					对指定范围之外的其它的方法进行访问控制；
					
					limit_except  GET {
						allow  172.16.0.0/16;
						deny all;
					}
					
				20、limit_rate  speed;
					限制客户端每秒钟所能够传输的字节数，默认为0表示无限制；
					
			文件操作优化相关的配置
			
				21、aio  on|off;
					
				22、directio  size|off;
					Enables the use of the O_DIRECT flag (FreeBSD, Linux), the F_NOCACHE flag (Mac OS X), or the directio() function (Solaris), when reading files that are larger than or equal to the specified size.
					
				23、open_file_cache off;
					open_file_cache max=N [inactive=time];
						nginx可以缓存以下三种信息：
							(1) 文件描述符、文件大小和最近一次的修改时间；
							(2) 打开的目录的结构；
							(3) 没有找到的或者没有权限操作的文件的相关信息；
							
						max=N表示可缓存的最大条目上限；一旦达到上限，则会使用LRU算法从缓存中删除最近最少使用的缓存项；
						
						inactive=time：在此处指定的时长内没有被访问过的缓存项是为非活动缓存项，因此直接删除；
						
				24、open_file_cache_errors on | off;
					是否缓存找不到其路径的文件，或没有权限没有权限访问的文件相关信息；
					
				25、open_file_cache_valid time;
					每隔多久检查一次缓存中缓存项的有效性；默认为60s; 
					
				26、open_file_cache_min_uses number;
					缓存项在非活动期限内最少应该被访问的次数；
					
			ngx_http_access_module模块的配置（基于IP的访问控制）
				27、allow address | CIDR | unix: | all;
				28、deny address | CIDR | unix: | all;
				
					应用上下文：http, server, location, limit_except

			ngx_http_auth_basic_module模块的配置（basic认证）
				29、auth_basic string | off;
					使用http basic认证协议对用户进行认证；
					
				30、auth_basic_user_file file;
					实现用户认证的账号文件；
						
						文件格式：
							name1:password1
							name2:password2:comment
							
						密码格式：
							(1) encrypted with the crypt() function; 
							(2) md5加密; 
							
							location /admin/ {
							auth_basic "Admin Area";
							auth_basic_user_file /etc/nginx/.ngxhtpasswd;
							}					
			
			ngx_http_log_module模块的配置（访问日志）
				31、log_format  name  string  ...;
					定义日志格式及其名称；日志格式一般通过调用内置变量来定义；
					
				32、access_log path [format [buffer=size [flush=time]]];
					access_log off;
				
					访问日志文件路径，格式名称以及缓存大小和刷写时间间隔；建议定义缓冲以提升性能；
					
				33、open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];
					open_log_file_cache off;
					
			ngx_http_stub_status_module模块配置：
				34、stub_status;
					通过指定的uri输出stub status；
					
					Active connections: 291 
					server accepts handled requests
					16630948 16630948 31070465 
					Reading: 6 Writing: 179 Waiting: 106 				
					
					Active connections：当前活动的客户端连接数；
					accepts：已经接受的客户端连接总数量；
					handled：已经处理过后客户端连接总数量；
					requests：客户端的总的请求数量；
					Readking：正在读取的客户端请求的数量；
					Writing：正向其发送响应报文的连接数量；
					Waiting：等待其发出请求的空闲连接数量；
					
				
			ngx_http_referer_module模块配置（基于请求报文中的Referer首部的值做访问控制）
				35、valid_referers  none | blocked | server_names | string ...;
				
					none：请求报文不存在referer首部；
					blocked：请求报文中存在referer首部，但其没有有效值，或其值非以http://或https://开头；
					server_names：其值为一个主机名；
					arbitrary string：直接字符串，可以使用*通配符；
					regular expression：以~起始的正则表达式；
					
					内置变量：$invalid_referer（所有不能符合valid_referer指定定义的引用请求均为不合法引用）
					
				示例
					valid_referers   none   blocked   server_names   *.example.com   example.*  www.example.org/galleries/   ~\.google\.;	
					if ($invalid_referer) {
						return  403;
					}
					
回顾：Nginx配置

	core, http, modules
	
	main配置段
	events {
		...
	}
	http {
		server {
			...
		}
		server {
			...
			listen 
			server_name
			location [=|^~|~|~*] / {
				root 
				...
			}
		}
	}
						
Nginx(3) 

	ngx_http_ssl_module模块配置
	
		ssl_certificate file; 
			证书文件路径；
		ssl_certificate_key file;
			证书对应的私钥文件；
		ssl_ciphers ciphers;
			指明由nginx使用的加密算法，可以是OpenSSL库中所支持各加密套件；
		ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2];
			指明支持的ssl协议版本，默认为后三个；
		ssl_session_cache off | none | [builtin[:size]] [shared:name:size];
			指明ssl会话缓存机制；
				builtin：使用OpenSSL内置的ssl会话缓存，对机制为各worker私有；
				shared：在各worker之间使用一个共享的缓存；
					name：独有名称；
					size：缓存空间大小；
		ssl_session_timeout time;
			ssl会话超时时长；即ssl session cache中的缓存有效时长；
		
	ngx_http_rewrite_module模块配置
		将请求的url基于正则表达式进行重写；
			http --> https,  domain1.tld --> domain2.tld, uri1 --> uri2, ...
		
		指令：
			rewrite  regex  replacement [flag];
				regex：正则表达式，用于匹配用户请求的url；
				replacement：重写为的结果；
				[flag]：
					last：重写完成之后停止对当前uri的进一步处理，改为对新url的新一轮处理；
					break：重写完成之后停止当uri的处理，转向其后面的其它配置；
					redirect：重写完成之后会返回客户端一个临时的重定向，由客户端对新的url重新发起请求（302）；
					permanent：重写完成之后会返回客户端一个永久的重定向，由客户端对新的url重新发起请求（301）；
			
					server {
						...
						rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
						rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;
						return  403;
						...
					}				
					
					http://www.magedu.com/download/a/b/c/media/32.wmv  --> 
						/download/a/b/c/mp3/32.mp3
						
				PCRE正则表达式元字符
					字符匹配：., [ ], [^]
					次数匹配：*, +, ?, {m}, {m,}, {m,n}
					位置锚定：^, $
					或者：|
					分组：(), 后向引用, $1, $2, ...
			
			if (condition) { ... }
				条件判断，引用新的配置上下文；
				
				condition：
					比较表达式：
						==，!=
						~：模式匹配，区分字符大小写；
						~*：模式匹配，不区分字符大小写；
						!~：模式不匹配，区分字符大小写；
						!~*: 模式不匹配，不区分字符大小写；
					文件及目录判断：
						-f, !-f：是否存在且为普通文件；
						-d, !-d: 是否存在且为目录；
						-e, !-e：是否存在；
						-x, !-x：是否存在且可执行；
			
			return code [text];
			return code URL;
			return URL;
				立即停止对请求的uri的处理，并返回指定的状态码；
				
			set $variable value;	
				变量赋值；
				
			rewrite_log on | off;
				是否将重写日志记入error log中，默认为关闭；
				
			调试方法：
				错误日志debug；
				开启rewrite_log；
				
		ngx_http_gzip_module模块配置
			
			gzip on | off;
				启用或禁用gzip压缩响应报文；
			gzip_comp_level level;
				压缩比，1-9，默认为1; 
			gzip_disable regex ...;
				regex是为用于匹配客户端响应器类型的正则表达式；
				表示对何种浏览器禁止使用压缩功能；
			gzip_min_length length;
				触发压缩功能的响应报文的最小长度；
			gzip_http_version 1.0 | 1.1;
				设定启用压缩功能时，协议的最小版本；
			gzip_proxied off | expired | no-cache | no-store | private | no_last_modified | no_etag | auth | any ...;
				定义对客户端请求的具有何种请求属性的资源启用压缩功能；如expired则表示对由于使用了expire首部而无法缓存的对象启用压缩功能；
			gzip_types mime-type ...;
				指明仅对哪些类型的资源执行压缩操作；即压缩过滤器；
			
			示例：
				gzip  on;
				gzip_http_version 1.0;
				gzip_comp_level 6;
				gzip_disable msie6;
				gzip_min_length 2;
				gzip_types text/plain text/css text/xml application/x-javascript application/xml application/json application/java-script;				
			
		实践作业：
			提供http及https虚拟主机，要求：
				(1) 对http虚拟主机的请求统统定向至https；
					额外测试：仅把对/admin/的请求定向至https;
				(2) 对常见支持较好压缩比的资源执行压缩响应；
				
		ngx_http_fastcgi_module模块配置（fastcgi协议代理）
		
			LAMP：
				httpd+php:
					module (libphp5.so)
					cgi 
					fastcgi：后端提供cgi server process； 
						Client: fastcgi client
						Server： fastcig Server 
													
			LNMP：
				nginx: ngx_http_fastcgi_module
				php-fpm：fastcgi
				php-mysql: mysql-server, mariadb-server
				
				server {
					...
					location ~* \.php$ {
						...
					}
					
			编译php工作为fpm机制时：
				./configure ...  --enable-fpm ...
				
				php-fpm的工作方式：
					listen = 127.0.0.1:9000
					listen.allowed_clients = 127.0.0.1
					pm = dynamic|static 
						pm.start_servers：启动fpm进程时启动的工作进程数量；
						pm.min_spare_servers：最少空闲进程数；
						pm.max_spare_servers：最大空闲进程数；
						pm.max_children：最大工作进程数；
				user = USERNAME
				group = GROUPNAME
				
			fastcgi模块指令：
			
				(1) fastcgi_pass address;
					address为fastcgi server监听的地址；
					
					示例：fastcgi_pass   127.0.0.1:9000;
					
				(2) fastcgi_index name;
					定义fastcgi应用的默认主页；
					
					示例：fastcgi_index  index.php;
					
				(3) fastcgi_param parameter value [if_not_empty];
					设定传递给后端fastcgi server参数及其值； 
					
					示例：fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
						
					/index.php --> /scripts/index.php
						http://www.magedu.com/users.php?username=tom
						
				(4) fastcgi_cache_path path  [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size];
					定义缓存：缓存空间等；
					
					可应用的上下文 ：http 
					缓存机制：
						元数据：内存，即为keys_zone；
						数据：磁盘，即为path; 
						
					levels=#[:#[:#]]
						levels=2:1
						
					keys_zone=name:size
						name: cache的标识符；
						size：元数据cache大小；
						
					max_size：缓存空间上限；
					
				(5) fastcgi_cache zone | off;
					调用定义过的缓存；
					
					zone即为通过fastcgi_cache_path定义缓存时其keys_zone参数中的name；
					
				(6) fastcgi_cache_key string;
					定义如何使用缓存键；
					
					使用示例：fastcgi_cache_key   $request_uri;
					
				(7) fastcgi_cache_methods GET | HEAD | POST ...;
					为何请求方法对应的请求进行缓存，默认为GET和HEAD；
					
				(8) fastcgi_cache_min_uses number;
					缓存项的最少使用次数；
					
				(9) fastcgi_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_503 | http_403 | http_404 | off ...;
					是否可使用stale缓存项响应用户请求；
					
				(10) fastcgi_cache_valid [code ...] time;
					对不同响应码的响应设定其可缓存时长；
					
					示例：
						fastcgi_cache_valid 200 302 10m;
						fastcgi_cache_valid 404      1m;					
				
				注意：调用缓存时，至少应该指定三个参数
					fastcgi_cache
					fastcgi_cache_key
					fastcgi_cache_valid 
					
		
回顾：Nginx ssl、url rewrite、gzip、fastcgi				
					
	ssl
	url rewrite (pcre-devel)：
		rewrite  regexp  replacement  [flag];
			flag: 
				last、break、redirect、permanent
		return code url;
		if (condition) {
			...
		}
	gzip：
		gzip on|off;
	fastcgi：
		location ~* \.php$ {
			fastcgi_pass BACKEND;
			fastcgi_index 
			fastcgi_param
		}
		
		缓存：先定义(http)，后调用(server, location, if)
			定义：
				fastcgi_cache_path 
			调用：
				fastcgi_cache
				fastcgi_cache_key
				fastcgi_cache_valid
			
Nginx(4)
	
	nginx_http_fastcgi_module模块配置
		
		LNMP： 
			php主机：php-mysql、php-xcache
			
			思考？
				redis: php的redis扩展；
				memcached：php的memcached扩展；
				
	ngx_http_proxy_module模块配置（http或https协议代理）
		
		(1) proxy_pass URL;
			应用上下文：location, if in location, limit_except
			
			proxy_pass后面的路径不带uri时，其会将location的uri传递给后端的主机；下面的示例会将/uri/传递给backend服务器；
				location  /uri/ {
					proxy_pass http://hostname;
				}
				
			proxy_pass后面的路径是一个uri时，其会将location的uri替换为后端主机自己的uri；
				location  /uri/ {
					proxy_pass http://hostname/new_uri/;
				}
				
			如果location定义其uri时使用的正则表达式模式匹配，则proxy_pass后的路径不能够使用uri；
				location  ~*  \.(jpg|gif|jpeg)$  {
					proxy_pass  http://HOSTNAME;
				}
				
				此处的http://HOSTNAME后面不能有任何uri，哪怕只有/也不可以；
				
		(2) proxy_set_header field value;
			用于proxy server向backend server发请求报文时，将某请求首部重新赋值，或在原有值后面添加一个新的值； 也可以添加自定义首部； 
			
			示例：
				proxy_set_header  X-Real-IP  $remote_addr;
				proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;
					原有请求报文中如果存在X-Forwared-For首部，则将remote_addr以逗号分隔补原有值后，否则则直接添加此首部；
			
			实践作业：
				假如nginx有两个server（虚拟主机），且均反代至后端某一个主机，此主机亦有两个虚拟主机，虚拟主机名与nginx的相同；
				要求：用户请求nginx的哪一个虚拟主机，就将其代理后后端主机的对应的虚拟主机；				
				
				
		
		缓存相关的选项（缓存要先定义，后调用）：
		(3) proxy_cache_path path [levels=levels] [use_temp_path=on|off] keys_zone=name:size [inactive=time] [max_size=size] 
			定义缓存；可用上下文为http; 
			
		(4) proxy_cache zone | off;
			调用缓存；可用上下文 为http, server和location；
			
		(5) proxy_cache_key string;
			定义缓存键；
			proxy_cache_key $scheme$proxy_host$request_uri;
				
		(6) proxy_cache_valid [code ...] time;
			对不同响应码的响应设定其可缓存时长；
			示例：
				proxy_cache_valid 200 302 10m;
				proxy_cache_valid 404      1m;	
				
		proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | off ...;
		
		跟连接相关的选项
		(7) proxy_connect_timeout time;
			定义与后端服务器建立连接的超时时长；默认为60s，不建议超出75s; 
			
		(8) proxy_send_timeout time;
			把请求发送给后端服务器的超时时长；默认为60s;
			
		(9) proxy_read_timeout time;
			等待后端服务器发送响应报文的超时时长；					
	
	ngx_http_headers_module模块配置
		
		(1) add_header name value [always];
			向响应报文添加自定义首部，并为其赋值；
			
		(2) expires [modified] time;
		      expires epoch | max | off;		      
		      允许或禁止向响应报文的Cache-Control或Expires首部添加新值或修改其值； 
		      
	ngx_http_upstream_module模块配置
		用于将多个服务器定义成服务器组，而由proxy_pass, fastcgi_pass等指令进行引用；
		
		(1) upstream name { ... }
			定义一个后端服务器组，name为组名称；仅能用于http上下文 ；
			
		(2) server address [parameters];
			在upstream中定义一个服务器及其相关参数；仅能用于upstream上下文；
			
			常用参数：
				weight=number：定义服务器权重，默认为1；
				max_fails=number：最大失败连接尝试次数，失败连接超时时长由fail_timeout参数指定；
				fail_timeout=number：等待目标服务器发送响应的时长；
				backup：备用服务器，所有主服务器均故障时才启用此主机；
				down：手动标记其不再处理任何用户请求；
				
		使用方法：
			(a) 定义upstream服务器组
				upstream websrvs {
					server 172.16.100.68 weight=2 max_fails=2 fail_timeout=6s;
					server 172.16.100.6  weight=1 max_fails=2 fail_timeout=6s;
				}				
			
			(b) 在反代场景中（proxy_pass, fastcgi_pass, ...）进行调用；
				location / {
					proxy_pass http://websrvs/;
				}
				
		(3) ip_hash;
			源地址hash，把来自同一个ip地址的请求始终发往同一个backend server，除非此backend server不可用；
			
		(4) least_conn;
			最少连接；当各server权重不同时，即为加权最少连接；
			
		(5) health_check [parameters];
			健康状态检测机制；只能用于location上下文；
			
			常用参数：
				interval=time检测的频率，默认为5秒；
				fails=number：判定服务器不可用的失败检测次数；默认为1次；
				passes=number：判定服务器可用的失败检测次数；默认为1次；
				uri=uri：做健康状态检测测试的目标uri；默认为/；
				match=NAME：健康状态检测的结果评估调用此处指定的match配置块；
				
		
		(6) match name { ... }
			对backend server做健康状态检测时，定义其结果判断机制；只能用于http上下文；
				
			常用的参数：
				status  code[  code ...]: 期望的响应状态码；
				header  HEADER[operator  value]：期望存在响应首部，也可对期望的响应首部的值基于比较操作符和值进行比较；
				body：期望响应报文的主体部分应该有的内容；
				
		(7) hash key [consistent];
			指明基于hash方式进行调度时，其hash key；
				hash  $remote_addr相当于ip_hash；
				
			常用的hash key:
				$cookie_name：将一个用户的请求始终发往同一个backend server，能实现会话绑定的功能；此处的name为cookie某些参数的名称，此处常用的有cookie_username；
				$request_uri: 将对同一个uri的请求始终发往同一个backend server，后端为cache server时特别有用；
				
	session会话保持：
		session sticky：基于ip, ngix还可基于请求报文首部中的多种信息，例如cookie, uri；
		session cluster：每个server均把创建和维护session同步集群中的其它主机；仅适用于较小规模的环境；
		session server：使用一个共享的存储服务存储session信息；
		
		location ~* \.php$ {
			proxy_pass
		}
		
		location / {
			proxy_pass
		}
		
	课外实践：
		(1) http 重定向至https; 
		(2) gzip效果测定；
		(3) 各种调度算法测试；
			hash $request_uri
			hash $cookie_username			
		(4) 动静分离；
		(5) 做方法分离；
		
	实践：
		尝试使用tengine实现上述所有功能；并了解tengine自己的独有特性；
		
memcached：

	MariaDB, MySQL: 数据存储服务
		DML：CRUD：增查改删
		DDL
		
		关系模型：结构化数据（structured data）
		
	NoSQL, NewSQL
	
	Strore (persistent), cache
	
	K/V cache：
		k: v
			name = tom
			name = jerry
			
		cache, kv, bypass
		
		LiveJournal旗下的Danga Interactive；
		
		特性：
			k/v缓存：可序列化数据；存储项：key/value, 标志，过期时间；
			功能的实现一半依赖于服务端，一半依赖客服端；
			分布式缓存，各服务器之间互不通信；
			O(1)的执行交流；
			清理过期数据：LRU 
			
			命令：
				存储类命令：set, add, replace, append, prepend
				获取数据类命令：get, delete, incr/decr
				统计类命令：stats,  stats items, stats slabs, stats sizes
				清理：flush_all
				
		安装：
			# yum install memcached
			程序配置：/etc/sysconfig/memcached
			service unit: memcached.service
			
			11211/tcp, 11211/udp
			
		memcached程序的常用选项：
			-l  IP：监听的IP地址；
			-m <num>：用于缓存数据的内存空间大小，单位为MB，默认为64；
			-c <num>：最大并发连接数；
			-p PORT：tcp端口
			-U PORT：UDP端口
			-t <num>：用于处理请求的最大线程数；
			-M：内存耗尽时返回错误信息，而不是LRU算法清理；
			-f <num>： growth factor, 增长因子；
			-n <num>：指明最小的slab大小，默认是96；
			
		php连接memcached服务器的扩展：
			php-pecl-memcache 
			libmemcached
			python-memcache
			
		默认没有认证功能，但可借助于sasl实现认证
			sasl：simple authentication layer
			
		分布式缓存场景中：
			缓存，查询：
				取模法；
					mykey --> hash成数字 % 2
						0, 1
				一致性hash算法；
				
		
					
			
			
			
回顾：nginx upstream, fastcgi
	upstream name {
		server  
		server 
		
	}
	wrr
	ip_hash|least_conn|sticky
	
	fastcgi_pass fastcgi://
	
	LNMMP: Memcached
	
HAProxy: 
	
	



	web arch: haproxy
		mode: http, tcp (https, mysql)

	HAProxy: 
		代理(http): 掮客(broker)
			正向代理：
			反向代理：

			代理作用：web缓存（加速）、反向代理、内容路由（根据流量及内容类型等将请求转发至特定服务器）、转码器；

				在代理服务器上添加Via首部；

			缓存的作用：
				减少冗余内容传输；
				节省带宽、缓解网络瓶颈；
				降低了对原始服务器的请求压力；
				降低了传输延迟；

		HAProxy: 只是http协议的反向代理，不提供缓存功能；但额外支持对tcp层对基于tcp通信的应用做LB；

			nginx：
				server {

				}

				server {
					location ~* \.php$ {
						proxy_pass
					}

					location / {

					}
				}


				upstream {
					leastconn
					server
					server
				}

				upstream {

				}

			haproxy:
				frontend
					use_backend
					default_backend
				backend
					balancer
					server
					server

				listen: 
					server
				
				default

	配置文件：haproxy.cfg
		全局配置
		代理配置


回顾：
	HAProxy:
		http协议反向代理
		tcp层的LB

		特性：event-driven, ebtree

	配置：/etc/haproxy/haproxy.cfg
		/usr/sbin/haproxy

		CentOS 6: /etc/rc.d/init.d/haproxy
		CentOS 7: haproxy.service

		配置分为两段：
			global
				配置参数：log, maxconn, ...
			proxies
				defaults, frontend, backend, listen

		示例：
			frontend main *:80
				default_backend websrvs

			backend websrvs
				balance roundrobin
				server web1 172.16.100.68 check
				server web2 172.16.100.69 check

HAProxy(2)

	代理参数：
		balance: 指明调度算法；
			动态：权重可动态调整
			静态：调整权重不会实时生效

			roundrobin: 轮询，动态算法，每个后端主机最多支持4128个连接；
			static-rr: 轮询，静态算法，每个后端主机支持的数量无上限；
			leastconn: 根据后端主机的负载数量进行调度；仅适用长连接的会话；动态；
			source:
				hash-type:
					map-based：取模法；静态；
					consistent：一致性哈希法；动态；
			uri:
				hash-type
					map-based:
					consistent:
			url_param: 根据url中的指定的参数的值进行调度；把值做hash计算，并除以总权重；
				hash-type
					map-based:
					consistent:
			hdr(<name>)	：根据请求报文中指定的header(如use_agent, referer, hostname)进行调度；把指定的header的值做hash计算；
				hash-type
					map-based:
					consistent:

		bind：
			只能用于frontend, listen; 

		mode: 
			HAProxy的工作模式；默认为tcp；
				tcp, http, health

		log:

		maxconn:

		default_backend: 
			为frontend指明使用的默认后端；

			use_backend: 条件式后端调用；


			K.I.S.S: Keep it simple, stupid.

		server:

			server <name> <addr>[:port] [param*]
				backup: 设定当前server为backup server；
				check: 健康状态检测；
					inter <delay>：检测时间间隔；单位为ms, 默认为2000; 
					fall: up --> down, soft state, soft state, hard state; 
					rise：down --> up, 
				cookie <value>：
				maxconn: 此服务接受的并发连接的最大数量；
				maxqueue: 请求队列的最大长度；
				observe: 根据流量判断后端server的健康状态；
				weight: 指定权重，默认为1，最大为256；0表示不被调度；
				redir <prefix>: 重定向；所有发往此服务器的请求均以302响应；

			后端http服务时的健康状态的检测方法：
				option httpchk

		基于浏览器cookie实现session sticky：
			backend websrvs
			    balance     roundrobin
			    cookie SERVERID insert nocache indirect
			    server web1 172.16.100.68:80 check weight 1 cookie websrv1
			    server web2 172.16.100.69:80 check weight 3 cookie websrv2

			要点：
				(1) 每个server有自己惟一的cookie标识；
				(2) 在backend中定义为用户请求调度完成后操纵其cookie

		启用stats：
			listen statistics 
			    bind *:9090
			    stats enable
			    stats hide-version
			    #stats scope .
			    stats uri /haproxyadmin?stats
			    stats realm "HAPorxy\ Statistics"
			    stats auth admin:mageedu
			    stats admin if TRUE

		向日志中记录额外信息：
			capture request header
			capture response header

		当mode为http时，记录丰富的日志信息：
			option httplog

		错误页面重定向：
			errorfile: 使用haproxy主机本地文件进行响应；
			errorloc, errorloc302: 使用指定的url进行响应，响应状态码为302；不适用于GET以外的其它请求方法；
			errorloc303：返回303状态码；

	访问控制：
		http_request
		tcp_request

	添加请求或响应报文首部：
		reqadd
		rspadd

	ACL
		定义，及调用；

	作业：
		1、基于cookie实现会话绑定；
		2、基于uri实现调度；
		3、基于hdr实现调度；
		4、动静分离；
			基于lamp部署discuz，而动静分离；
		5、用keepalived高可用haproxy；
	博客作业：以上所有内容；



	补充：动静分离的示例：

			frontend  main
			    bind *:80
			    bind *:8080
			    acl url_static       path_beg       -i /static /images /javascript /stylesheets
			    acl url_static       path_end       -i .jpg .gif .png .css .js

			    use_backend static          if url_static
			    default_backend             appsrvs

			#---------------------------------------------------------------------
			# static backend for serving up images, stylesheets and such
			#---------------------------------------------------------------------
			backend static
			    balance roundrobin
			    server static1 172.16.100.11 check
			    server static2 172.16.100.12 check

			backend appsrvs
			    balance     roundrobin
			    option forwardfor except 127.0.0.1 header X-Client
			    option httpchk
			    cookie SERVERID insert indirect nocache
			    server  web1 172.16.100.7:80 check cookie web1
			    server  web2 172.16.100.8:80 check cookie web2	



回顾：
	haproxy: 
		tcp lb, http reverse proxy

		配置：
			global
			proxies:
				defaults
				frontend
				backend
				listen

				参数：bind, mode, cookie, balance, server, log, maxconn, use_backend, default_backend, acl

			balance:
				roundrobin, static-rr, leastconn, source, uri, url_param, hdr(HEADER)
				hash-type:
					map-based
					consistent

			acl:
				acl <name> creterion flags operator value
					path, path_beg, path_end, src, src_port, dst, dst_port, url_beg, url_end, url_reg, path_reg, hdr(HEADER)

Web Cache

	程序具有局部性：
		时间局部性
		空间局部性

		key-value:
			key: 访问路径，URL, hash
			value：web content	

		热点数据：	

	命中率：hit/(hit+miss)	
		文档命中率：从文档个数进行衡量；
		字节命中率：从内容大小进行衡量；

	注意：
		缓存对象：生命周期；定期清理；
		缓存空间耗尽：LRU（最近最少使用）
		可缓存，不可缓存（用户私有数据）

	缓存处理的步骤：
		接收请求 --> 解析请求 （提取请求的URL及各种首部）--> 查询缓存 --> 新鲜度检测 --> 创建响应报文 --> 发送响应 --> 记录日志

	新鲜度检测机制：
		过期日期：
			HTTP/1.0 Expires
				Expires:Thu, 04 Jun 2015 23:38:18 GMT
			HTTP/1.1 Cache-Control: max-age
				Cache-Control:max-age=600

		有效性再验正：revalidate
			如果原始内容未改变，则仅响应首部（不附带body部分），响应码304 （Not Modified）
			如果原始内容发生改变，则正常响应，响应码200；
			如果原始内容消失，则响应404，此时缓存中的cache object也应该被删除；

		条件式请求首部：
			If-Modified-Since：基于请求内容的时间戳作验正；
			If-Unmodified-Since
			If-Match：
			If-None-Match：
				Etag: faiy89345


	Cache-Control   = "Cache-Control" ":" 1#cache-directive
	    cache-directive = cache-request-directive
	         | cache-response-directive
	    cache-request-directive =
	           "no-cache"                          
	         | "no-store" (backup)                          
	         | "max-age" "=" delta-seconds         
	         | "max-stale" [ "=" delta-seconds ]  
	         | "min-fresh" "=" delta-seconds      
	         | "no-transform"                      
	         | "only-if-cached"                   
	         | cache-extension                   
	     cache-response-directive =
	           "public"                               
	         | "private" [ "=" <"> 1#field-name <"> ] 
	         | "no-cache" [ "=" <"> 1#field-name <"> ]
	         | "no-store"                            
	         | "no-transform"                         
	         | "must-revalidate"                     
	         | "proxy-revalidate"                    
	         | "max-age" "=" delta-seconds            
	         | "s-maxage" "=" delta-seconds           
	         | cache-extension 

	常见的缓存服务开源解决方案：
		varnish, squid   (类似nginx --> apache)
		nginx, apache


	Web Cache：
		squid, varnish

		https://www.varnish-cache.org

		DSL: vcl

		管理进程：编译VCL并应用新配置；监控vanish；初始化varnish；CLI接口；
		Child/cache：
			Acceptor：接收新的连接请求；
			worker threads：处理用户请求；
			Expiry：清理缓存中的过期对象；

		日志：Shared Memory Log，共享内存日志大小默认一般为90MB，分为两部分，前一部分为计数器，后一部分请求相关的数据；

		vcl: Varnish Configuration Language
			缓存策略配置接口；
			基于“域”的简单编程语言；

		内存分配和回收：
			malloc(), free()

		varnish如何存储缓存对象：
			file: 单个文件；不支持持久机制；
			malloc: 内存；
			persistent：基于文件的持久存储；

		配置varnish的三种应用：
			1、varnishd应用程序的命令行参数；
				监听的socket, 使用的存储类型等等；额外的配置参数；
					-p param=value 
					-r param,param,... : 设定只读参数列表；

					/etc/varnish/varnish.params

			2、-p选项指明的参数：
				运行时参数：
					也可在程序运行中，通过其CLI进行配置；

			3、vcl：配置缓存系统的缓存机制；
				通过vcl配置文件进行配置；
					先编译，后应用；
						依赖于c编译器；

		命令行工具：
			varnishadm -S /etc/varnish/secret -T IP:PORT

			Log:
				varnishlog
				varnishncsa

			Statistics
				varnishstat

			Top：
				varnishtop



回顾：
	http cache：
		Expires：
		Cache-Control:
			max-age
			s-maxage

		Cache-Control:
			no-cache
			no-store
			must-revalidate

		条件式请求：
			If-Modified-Since
			If-None-Match

	varnish:
		v2, v3, v4

		配置：
			varnishd进程配置；命令行选项；/etc/varnish/varnish.params
				-p
			varnishd Child/cahce：实时参数
				varnishadm
					param.set
			缓存功能配置：
				vcl
					/etc/varnish/default.vcl

varnish(2)

	vcl: 
		state engine：各引擎之间存一定程度上的相关性；前一个engine如果可以有多种下游engine，则上游engine需要用return指明要转移的下游engine；
			vcl_recv
			vcl_hash
			vcl_hit
			vcl_miss
			vcl_fetch
			vcl_deliver
			vcl_pipe
			vcl_pass
			vcl_error

		编程语言语法：
			(1) //, #, /* */ 用于注释；会被编译器忽略；
			(2) sub $name: 用于定义子例程；
				sub vcl_recv {

				}
			(3) 不支持循环；
			(4) 有众多内置的变量，变量的可调用位置与state engine有密切相关性；
			(5) 支持终止语句，return(action)；没有返回值；
			(6) "域"专用；
			(7) 操作符：=, ==, ~, !, &&, ||

			条件判断语句：
				if (CONDTION) {

				} else {

				}

			变量赋值：set name=value
				unset name

				req.http.HEADER：调用request报文中http协议的指定的HEADER首部；
					req.http.X-Forwarded-For
					req.http.Auhtorization
					req.http.cookie

				req.request: 请求方法

				client.ip: 客户端IP；

			state engine workflow(v3):
				vcl_recv --> vcl_hash --> vcl_hit --> vcl_deliver
				vcl_recv --> vcl_hash --> vcl_miss --> vcl_fetch --> vcl_deliver
				vcl_recv --> vcl_pass --> vcl_fetch --> vcl_deliver
				vcl_recv --> vcl_pipe

			state engine(v4)
				vcl_recv
				vcl_pass
				vcl_pipe
				vcl_hash
				vcl_hit
				vcl_miss

				vcl_backend_fetch
				vcl_backend_response
				vcl_backend_error

				vcl_purge
				vcl_synth

				https://www.varnish-software.com/book/4.0/chapters/VCL_Basics.html


				sub vcl_recv {
				    if (req.method == "PRI") {
				        /* We do not support SPDY or HTTP/2.0 */
				        return (synth(405));
				    }

				    if (req.method != "GET" &&
				      req.method != "HEAD" &&
				      req.method != "PUT" &&
				      req.method != "POST" &&
				      req.method != "TRACE" &&
				      req.method != "OPTIONS" &&
				      req.method != "DELETE") {
				        /* Non-RFC2616 or CONNECT which is weird. */
				        return (pipe);
				    }

				    if (req.method != "GET" && req.method != "HEAD") {
				        /* We only deal with GET and HEAD by default */
				        return (pass);
				    }
				    if (req.http.Authorization || req.http.Cookie) {
				        /* Not cacheable by default */
				        return (pass);
				    }
				    return (hash);
				}				

			
			定义在vcl_deliver中，向响应给客户端的报文添加一个自定义首部X-Cache；
			    if (obj.hits>0) {
			        set resp.http.X-Cache = "HIT";
			    } else {
			        set resp.http.X-Cahce = "MISS";
			    }

		varnish中的内置变量：
			变量种类：
				client
				server
				req
				resp
				bereq
				beresp
				obj
				storage

				bereq
					bereq.http.HEADERS: 由varnish发往backend server的请求报文的指定首部；
					bereq.request：请求方法；
					bereq.url：
					bereq.proto：
					bereq.backend：指明要调用的后端主机；

				beresp
					beresp.proto
					beresp.status：后端服务器的响应的状态码
					beresp.reason：原因短语；
					beresp.backend.ip
					beresp.backend.name
					beresp.http.HEADER: 从backend server响应的报文的首部；
					beresp.ttl：后端服务器响应的内容的余下的生存时长；

				obj
					obj.ttl: 对象的ttl值；
					obj.hits：此对象从缓存中命中的次数；

				server
					server.ip
					server.hostname

				req

				resp

				官方文档：https://www.varnish-cache.org/docs/4.0/reference/vcl.html#varnish-configuration-language

	支持虚拟主机：
		
		if (req.http.host == "www.magedu.com") {

		}

	强制对某资源的请求，不检查缓存；
		/admin
		/login

		if (req.url ~ "(?i)^/login" || req.url ~ "(?i)^/admin") {
			return(pass);
		}

	对特定类型的资源取消其私有的cookie标识，并强行设定其可以varnish缓存的时长：
		vcl_backend_response
		if (beresp.http.cache-control !~ "s-maxage") {
			if (bereq.url ~ "(?i)\.jpg$") {
				set beresp.ttl = 3600s;
				unset beresp.http.Set-Cookie;
			}
			if (bereq.url ~ "(?i)\.css$") {
				set beresp.ttl = 600s;
				unset beresp.http.Set-Cookie;
			} 
		}

	官方配置示例：https://www.varnish-cache.org/trac/wiki/VCLExamples

	backend server的定义：
		backend name {
		    .attribute = "value";
		}	

		.host: BE主机的IP；
		.port：BE主机监听的PORT；

		.probe: 对BE做健康状态检测；
		.max_connections：并连接最大数量；

	后端主机的健康状态检测方式：
		probe name {
		     .attribute = "value";
		}	

		.url: 判定BE健康与否要请求的url; 
		.expected_response：期望响应状态码；默认为200；

		示例1：
			backend websrv1 {
			    .host = "172.16.100.68";
			    .port = "80";
			    .probe = {
			        .url = "/test1.html";
			    }
			}

			backend websrv2 {
			    .host = "172.16.100.69";
			    .port = "80";
			    .probe = {
			        .url = "/test1.html";
			    }
			}

			sub vcl_recv {
			    if (req.url ~ "(?i)\.(jpg|png|gif)$") {
			        set req.backend_hint = websrv1;
			    } else {
			        set req.backend_hint = websrv2;
			    }				
			}

		示例2：
			import directors;

			sub vcl_init {
			    new mycluster = directors.round_robin();
			    mycluster.add_backend(websrv1);
			    mycluster.add_backend(websrv2);
			}

			vcl_recv {
				set req.backend_hint = mycluster.backend();
			}

			负载均衡算法：
				fallback, random, round_robin, hash

	掌握：varnishlog, varnishncsa, varnishtop, varnishstat

	作业：
		vcl: backend, backend的调用，健康状态检测的定义，负载均衡的实现，根据资源类型不同完成分发，控制哪些内容不查或查询缓存；

	博客作业：以上所有内容；


	补充：
		移除单个缓存对象

			purge用于清理缓存中的某特定对象及其变种(variants)，因此，在有着明确要修剪的缓存对象时可以使用此种方式。HTTP协议的PURGE方法可以实现purge功能，不过，其仅能用于vcl_hit和vcl_miss中，它会释放内存工作并移除指定缓存对象的所有Vary:-变种，并等待下一个针对此内容的客户端请求到达时刷新此内容。另外，其一般要与return(restart)一起使用。下面是个在VCL中配置的示例。

			acl purgers {
				"127.0.0.1";
				"192.168.0.0"/24;
			}

			sub vcl_recv {
				if (req.request == "PURGE") {
					if (!client.ip ~ purgers) {
						error 405 "Method not allowed";
					}
					return (lookup);
				}
			}
			sub vcl_hit {
				if (req.request == "PURGE") {
					purge;
					error 200 "Purged";
				}
			}
			sub vcl_miss {
				if (req.request == "PURGE") {
					purge;
					error 404 "Not in cache";
				}
			}
			sub vcl_pass {
				if (req.request == "PURGE") {
					error 502 "PURGE on a passed object";
				}
			}

			客户端在发起HTTP请求时，只需要为所请求的URL使用PURGE方法即可，其命令使用方式如下：
			# curl -I -X PURGE http://varniship/path/to/someurl


	生产环境案例一则：

		acl purge {
		  "localhost";
		  "127.0.0.1";
		  "10.1.0.0"/16;
		  "192.168.0.0"/16;
		}

		sub vcl_hash {
		  hash_data(req.url);
		  return (hash);
		}

		sub vcl_recv {
		  set req.backend = shopweb;
		#  set req.grace = 4h; 
		  if (req.request == "PURGE") {
		    if (!client.ip ~ purge) {
		      error 405 "Not allowed.";
		    }
		    return(lookup);
		  }
		  if (req.request == "REPURGE") {
		    if (!client.ip ~ purge) {
		      error 405 "Not allowed.";
		    }
		    ban("req.http.host == " + req.http.host + " && req.url ~ " + req.url);
		    error 200 "Ban OK";
		  }
		  if (req.restarts == 0) {
		    if (req.http.x-forwarded-for) {
		      set req.http.X-Forwarded-For = req.http.X-Forwarded-For + ", " + client.ip;
		    } 
		    else {
		      set req.http.X-Forwarded-For = client.ip;
		    }
		  }
		  if (req.request != "GET" &&
		    req.request != "HEAD" &&
		    req.request != "PUT" &&
		    req.request != "POST" &&
		    req.request != "TRACE" &&
		    req.request != "OPTIONS" &&
		    req.request != "DELETE") {
		    /* Non-RFC2616 or CONNECT which is weird. */
		    return (pipe);
		  }
		  if (req.request != "GET" && req.request != "HEAD") {
		    /* We only deal with GET and HEAD by default */
		    return (pass);
		  }
		  if (req.http.Authorization) {
		    /* Not cacheable by default */
		    return (pass);
		  }
		 

		  if ( req.url == "/Heartbeat.html" ) {
		    return (pipe);
		  }
		  if ( req.url == "/" ) {
		    return (pipe);
		  }
		  if ( req.url == "/index.jsp" ) {
		    return (pipe);
		  }

		  if (req.http.Cookie ~ "dper=") {
		    return (pass);
		  }
		  if (req.http.Cookie ~ "sqltrace=") {
		    return (pass);
		  }
		  if (req.http.Cookie ~ "errortrace=") {
		    return (pass);
		  }
		#   if ( req.request == "GET" && req.url ~ "req.url ~ "^/shop/[0-9]+$" ) {
		  if ( req.url ~ "^/shop/[0-9]+$" || req.url ~ "^/shop/[0-9]?.*" ) {
		    return (lookup);
		  }

		 if ( req.url ~ "^/shop/(\d{1,})/editmember" || req.url ~ "^/shop/(\d{1,})/map" || req.url ~ "^/shop/(\d+)/dish-([^/]+)" ) {
		    return (lookup);
		  } 

		  return (pass);
		#   return (lookup);
		}

		sub vcl_pipe {
		  return (pipe);
		}

		sub vcl_pass {
		  return (pass);
		}

		sub vcl_hit {
		  if (req.request == "PURGE") {
		    purge;
		    error 200 "Purged.";
		  }
		  return (deliver);
		}

		sub vcl_miss {
		  if (req.request == "PURGE") {
		    error 404 "Not in cache.";
		  }
		#   if (object needs ESI processing) {
		#     unset bereq.http.accept-encoding;
		#   }
		  return (fetch);
		}


		sub vcl_fetch {
		  set beresp.ttl = 3600s;
		  set beresp.http.expires = beresp.ttl;
		  #set beresp.grace = 4h;
		#   if (object needs ESI processing) {
		#     set beresp.do_esi = true;
		#     set beresp.do_gzip = true;
		#   }

		  if ( req.url ~ "^/shop/[0-9]+$" || req.url ~ "^/shop/[0-9]?.*" ) {   
		    set beresp.ttl = 4h;
		  }

		 if ( req.url ~ "^/shop/(\d{1,})/editmember" || req.url ~ "^/shop/(\d{1,})/map" || req.url ~ "^/shop/(\d+)/dish-([^/]+)" ) {
		     set beresp.ttl = 24h;
		  } 

		  if (beresp.status != 200){
		    return (hit_for_pass);
		  }
		  return (deliver);
		}

		sub vcl_deliver {
		  if (obj.hits > 0){
		    set resp.http.X-Cache = "HIT";
		  } 
		  else {
		    set resp.http.X-Cache = "MISS";
		  }
		  set resp.http.X-Powered-By = "Cache on " + server.ip;
		  set resp.http.X-Age = resp.http.Age;
		  return (deliver);
		}

		sub vcl_error {
		  set obj.http.Content-Type = "text/html; charset=utf-8";
		  set obj.http.Retry-After = "5";
		  synthetic {""} + obj.status + " " + obj.response + {""};
		  return (deliver);
		}

		sub vcl_init {
		  return (ok);
		}

		sub vcl_fini {
		  return (ok);
		}

补充资料：
	varnish的线程模型：
		cache-worker线程
		cache-main线程：此线程只有一个，用于启动caceh；
		ban luker：
		acceptor：
		epoll：线程池管理器
		expire：清理过期缓存

		varnish定义其最大并发连接数：线程池模型：
			thread_pools：线程池个数；默认为2；
			thread_pool_max：单线程池内允许启动的最多线程个数；
			thread_pool_min
			thread_pool_timeout：多于thread_pool_min的线程空闲此参数指定的时长后即被purge；

	varnish的param查看及改变：
		param.show [-l] [param]
		param.set [param] [value]

	varnish的命令行工具：
		varnishadm, 

		varnishtop: 内存日志区域查看工具
			RxHeader User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.81 Safari/537.36

			其中：
				RxHeader：称为tag, 基于tag过滤，可使用-i或-x选项；
				User-Agent起始的内容：称为日志信息，可使用-I或-X选项进行过滤；

				-I regexp: 仅显示被模式匹配到的条目
				-X regexp：仅显示不被模式匹配到的条目
				-C: 忽略字符大小写；
				-d: 显示已有日志；

		varnishstat：
			-f field, field, ...
			-l: 列出所有可用字段
			-x: xml输出格式 
			-j: json输出格式

		varnishlog, varnishncsa
		
				
				
			
		
			
			
			
Tomcat：

	编程语言：
		系统级：C，C++， go, erlang
		应用组：C#，Java, Python, Perl, Ruby, php 
			虚拟机：jvm, pvm
	
	cgi: Common Gateway Interface
	
	动态网站：
		服务端技术：jsp, php
		客户端技术：js
		
		webapp server:
		
	Java编程语言：
		Sun, James Gosling, Green Project, Oak
		Java, SunWorld
		1995: Java 1.0, Write once ,Run Anywhere
		1996: JDK(Java Development Kit), 包含了一个JVM（Sun Classic VM）
			JDK 1.0： JVM， Applet, AWT
		1997: JDK 1.1
			JAR文档格式、JDBC、JavaBeans
		1998: JDK 1.2
			Sun把Java技术分拆为三个方向： Java 2
				J2SE：Standard Edition
				J2EE：Enterprise Edition
				J2ME：Mobile Edition
			代表性的技术：EJB，Java Plug-in, Swing, JIT编译器
		2000: JDK 1.3
			1999: HotSpot JVM
		2002: JDK 1.4
		
		2006: Sun开源了Java技术，GPL，并建立了OpenJDK组织来管理此些代码；
		
			Java 2 SE
			Java 2 EE
	
	编程范式的类别：指令+数据
		过程式编程语言：以指令为中心，数据服务于指令；
		对象式编程语言：以数据为中心，指令服务于数据；
		
		Java：纯面向对象；
		
	Java的体系结构：
		Java编程语言
		Java Class文件格式
		Java API
		Java VM
		
	jvm的核心组成：
		Class Loader
		执行引擎
		
	Java编程语言的特性：
		面向对象、多线程、结构化错误处理、垃圾收集、动态链接、动态扩展
		
		GC
		
	JVM的运行时区域：
		方法区：线程共享；用于存储被虚拟机加载的类信息、常量、静态变量；持久代；
		堆（heap）：是jvm所管理的内存中的最大一部分，也是GC管理的主要区域；主流的垃圾收集算法基于分代收集机制：新生代、老年代；
		Java栈：线程私有，存储线程自己的局部变量； 
		PC寄存器：线程独有内存空间；
		本地方法栈
			
	JAVA 2 EE:
		JAVA 2 SE: JDK 
		Servlet, JSP, EJB, JMS, JMX, JavaMail, ...
			
		JSP 
			<html>
				<title>
				</title>
				<body>
					<h1>...</h1>
					<%
						
					%>
				</body>
			</html>
			
		a.jsp --> jasper --> a.class 
			
		web container:
			JDK, Servlet, JSP
			
			商业实现：
				WebSphere(IBM)
				WebLogic (BEA --> Orace)
				Oc4j
				Glassfish
				Geronimo
				JOnAS
				JBoss
				
			开源实现：
				Tomcat
				Jetty
				Resin
				
	Tomcat：
		Servlet container， Java  Web Server, JWS
		ASF, JServ
		
		Tomcat 3.x, 
		2001: tomcat 4.0, catalina, 8.x
		
		JAVA 2 EE: Servlet, JSP, JMX
			EJB: Enterprise JavaBeans 
			JMS: 
			JMX: Java Management Extensions
			JTA：
			JavaMail：
			
		JAVA 2 SE:
			JNDI: Java Naming and Directory Interface, LDAP
			JAXP：Java API for XML processing 
			
		http://www.magedu.com/
			/var/www/html/
				bbs/
				wordpress/
				
			http://www.magedu.com/bbs
			
		tomcat的组件：
			<Server>
				<Service>
					<connector/>
					<connector/>
					<Engine>
						<Host />
						<Host>
							<Context/>
							...
						</Host>
					</Engine>
				</Service>
			</Server>
			
			每个组件，均有java类来实现；
			
			此些组件可分为如下几类：
				顶级组件：Server
				服务类：Service
				连接器：http, https, ajp(apache jserv protocol)
				容器类：Engine, Host, Context
				被嵌套的组件：valve, logger, realm, loader, manager
				集群类组件：listener, ...
				
		安装：
			(1) 系统自带的openjdk+tomcat；
				java-1.7.0-openjdk
				java-1.7.0-openjdk-devel
				
				/etc/profile.d/java.sh
				export JAVA_HOME=/usr/bin
				
				tomcat
				tomcat-lib
				tomcat-webapps
				tomcat-admin-webapps
				
				默认连接器：
					http, 8080
					ajp, 8009
					
			(2) 使用Oracle JDK和tomcat主站提供的编译完成的程序包 
				rpm  -ivh  jdk-8u25-linux-x64.rpm
				
				tar  xf  apache-tomcat-VERSION-tar.gz   -C  /usr/local
				cd  /usr/local
				ln  -s  apache-tomcat-VERSION  tomcat
				
				tomcat的目录结构：
					bin: 脚本及启动时用到类；
					lib：类库；
					conf：配置文件；
					logs：日志文件；
					webapps：webapp的默认部署目录；
					work：工作目录；
					temp：临时文件目录；
					
		tomcat的配置文件：
			server.xml：主配置文件；
			context.xml：每个webapp都可以有专用的配置文件，这些配置文件通常位于webapp程序目录下的WEB-INF目录中，用于定义会话管理顺、JDBC等 ；conf/context.xml是为各webapp提供默认配置；
			web.xml：每个webapp只有在“部署”之后才能够被访问；此文件则用于为各webapps定义默认的部署操作方式； 
			tomcat-users.xml：用户认证的账号和密码配置文件；
			catalina.policy：当使用-security选项来启动tomcat实例时会读取此配置文件来实现基于安全策略的运行方式；
			catalina.properties：Java属性的定义文件，用于设定类加载器路径等 ，以及一些与JVM性能相关的调优参数；
			logging.properties：日志系统相关的配置；
			
		Java Webapp的组织结构：
			有特定的组织形式、层次型的目录结构；主要包含了servlet代码文件、JSP页面文件、类文件、部署描述符文件等 ；
				/：webapps的根目录
				index.jsp：jsp的主页面文件
				WEB-INF/：当前webapp的私有资源目录，通常存放当前webapp自用的web.xml；
				META-INF/：当前webapp的私有资源目录，通常存储当前webapp自用的context.xml；
				classes/: 当前webapp的私有类；
				lib/：当前webapp的私有类，被打包成jar格式；
				
			webapp归档格式：
				.war：webapp
				.jar：EJB的类；
				.rar：资源适配器；
				.ear：企业级应用程序；
				
回顾： java, tomcat

	java技术体系：Java编程语言，Java class文件格式，Java API, Java VM
	
		J2SE => JAVA 2 SE
		J2EE => JAVA 2 EE
		J2ME => JAVA 2 ME
				
	JAVA 2 SE: jdk (java development kit)
		Servlet, JSP, JMX, EJB, JMS, JavaMail, ...
		
		商业实现：WebSphere,  WebLogic, Oc4j, ...
		开源实现：Tomcat, Jetty, Resin
		
	jsp --> jasper --> servlet(PAGE_jsp.java) --> complier --> bytecode (PAGE_jsp.class) --> JVM 
	
	tomcat: JWS + Jserv
		catalina
		
		jdk + tomcat 
		
		tomcat: server.xml 
			<server>
				<service>
					<connector/>
					<engine>
						<host/>
						<host>
							<context/>
						</host>
					</engine>
				</service>
			</server>
			
		安装：
			openjdk+tomcat
			Oracle jdk+tomcat
			
			java
			
		webapp:
			/
			index.jsp
			...
			WEB-INF/
			META-INF/
			classes/
			lib/
			
tomcat(2) 

	手动添加一个测试应用程序：
		1、创建webapp特有的目录结构；
			mkdir  -pv  myapp/{classes,lib,WEB-INF,META-INF}
		2、提供webapp的测试页面：
			myapp/index.jsp 
			
			<%@ page language="java" %>
			<%@ page import="java.util.*" %>
			<html>
				<head>
					<title>JSP Test Page</title>
				</head>
				<body>
					<% out.println("hello world");
					%>
				</body>
			</html>			
				
		部署（deploy）webapp的相关操作：
			deploy：将webapp的源文件放置于目标目录、配置tomcat服务器能够基于context.xml文件中定义的路径来访问此webapp；将其特有的类通过class loader装载至tomcat：
				有两种方式：
					自动部署：auto deploy
					手动部署：
						(1) 冷部署：把webapp复制到指定位置，而后才启动tomcat；
						(2) 热部署：在不停止tomcat的前提下进行的部署：
							部署工具：manager app、ant脚本、tcd（Tomcat Client Deployer）等；
			undeploy：反部署，停止webapp，并从tomcat实例上拆除其部署文件和部署名；
			stop：停止，不再向用户提供服务；
			start：启动处于“停止”状态的webapp；
			redeploy：重新部署；
			
		tomcat自带的应用程序：
			manager app: webapp管理工具；
			host manager: VHosts管理工具；
			
		tomcat的常用组件：
			每个组件几乎都是通过特有的类来实现，而且有的组件还不止一种实现方式；
			
			Server：tomcat实例，即运行的一个jvm进程；监听于8005端口接收“SHUTDOWN”。各server监听的端口不能相同，因此，一个物理主机上启动多个server实例应该使用不同的端口；
			
			service：用于实现将一个或多个connector关联至一个engine；
				
			connector组件：
				进入tomcat的请求可分为两类：
					tomcat做为独立的应用程序服务器：standalone，此时，请求将来自于浏览器；
						http, https
					tomcat做为应用程序服务器：请求将来自于前面反代主机；
						httpd: http, https, ajp
						nginx: http, https
						
				属性：
					address：监听的IP地址；
					maxThreads：最大并发连接数，默认为150；
					port：监听的端口；
					protocol：连接器使用的协议，一般为HTTP/1.1或AJP/1.3；
					redirecPort：
					connectionTimeout：连接的超时时长，单位为毫秒，默认为60000；
					enableLookups：
					acceptCount：定义等待队列的长度；
					scheme：
					debug：
					secure：
					clinetAuth：
					sslProtocol:
					
			Engine：Servlet的一个实例，即servlet引擎，其内部可以有一个或多个Host组件来定义站点；通常需要通过defaultHost的属性定义默认虚拟主机；
			
				属性：
					name=
					defaultHost=
					jvmRoute=
					
			Host组件：
				位于Engine容器中用于接收请求并进行相应处理的主机或虚拟主机，如前面示例中的定义：
				<Host name="localhost" appBase="webapps"
					unpackWARs="true" autoDeploy="true"
					xmlValidation="false" xmlNamespaceAware="false">
						
				</Host>

				常用属性说明：
				1) appBase：此Host的webapps目录，即存放非归档的web应用程序的目录或归档后的WAR文件的目录路径；可以使用基于$CATALINA_HOME的相对路径；
				2) autoDeploy：在Tomcat处于运行状态时放置于appBase目录中的应用程序文件是否自动进行deploy；默认为true；
				3) unpackWars：在启用此webapps时是否对WAR格式的归档文件先进行展开；默认为true；


				虚拟主机定义示例：

				<Engine name="Catalina" defaultHost="localhost">
					<Host name="localhost" appBase="webapps">
					<Context path="" docBase="ROOT"/>
					<Context path="/bbs" docBase="/web/bss"
					reloadable="true" crossContext="true"/>
					</Host>
				
					<Host name="node2.magedu.com" appBase="/data/webapps">					
					</Host>
				</Engine>
				
				为第二个虚拟主机提供测试webapp：
					mkdir  -pv  /data/webapps/ROOT/{classes,lib,WEB-INF,META-INF}
					
			Context组件：
				示例：
					<Host name="node2.magedu.com" appBase="/data/webapps">		
						<Context path="/test"  docBase="testapp" reloadable="true"/>
						
					</Host>	
					
			Value组件：
				<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
					prefix="node2_access_log" suffix=".log"
					pattern="%h %l %u %t &quot;%r&quot; %s %b" />
					
				<Valve className="org.apache.catalina.valves.RemoteAddrValve" deny="172\.16\.100\.67"/>

				课外实践：将tomcat的访问日志格式定义为combined类型；
				
	LNMT：
		Client --> http --> Nginx --> reverse_proxy (http) --> tomcat (http connector)
		
		location /  {
			proxy_pass  http://web1.magedu.com:8080/;
		}
		
		
		
		location ~* \.(jsp|do)$ {
			proxy_pass http://app1.magedu.com:8080;
		}
		
	LAMT:
		Client --> http --> httpd --> reverse_proxy_module (http) --> tomcat (http connector)
		Client --> http --> httpd --> reverse_proxy_module (ajp) --> tomcat (ajp connector)	

		第一种方式：proxy_module, proxy_http_module
		第二种方式：proxy_module, proxy_ajp_module
		
		(1) 第一种方式的配置机制，使用虚拟主机
			<VirtualHost *:80>
				ServerName tc1.magedu.com
				ProxyRequests Off
				ProxyVia On
				ProxyPreserveHost On
				<Proxy *>
					Require all granted
				</Proxy>
				ProxyPass / http://localhost:8080/
				ProxyPassReverse / http://localhost:8080/
				<Location />
					Require all granted
				</Location>
			</VirtualHost>
		
		(2) 
		
			<VirtualHost *:80>
				ServerName tc1.magedu.com
				ProxyRequests Off
				ProxyVia On
				ProxyPreserveHost On
				<Proxy *>
					Require all granted
				</Proxy>
				ProxyPass / ajp://node2.magedu.com:8009/
				ProxyPassReverse / ajp://node2.magedu.com:8009/
				<Location />
					Require all granted
				</Location>
			</VirtualHost>
		
		
		Client --> http --> httpd --> mod_jk (ajp) --> tomcat (ajp connector)	
			
			
			
			
			
			
			

			
			
			
			
			
			
			
			
			
			
			
			
			